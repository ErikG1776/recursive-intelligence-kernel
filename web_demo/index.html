<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Intelligence - Compounding Intelligence Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(180deg, rgba(99, 102, 241, 0.1) 0%, transparent 100%);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, #818cf8, #c084fc, #818cf8);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 3s ease infinite;
        }

        @keyframes gradient {
            0%, 100% { background-position: 0% center; }
            50% { background-position: 200% center; }
        }

        .header p {
            margin-top: 10px;
            color: #9ca3af;
            font-size: 1.1rem;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Panels */
        .panel {
            background: rgba(30, 30, 46, 0.8);
            border-radius: 16px;
            border: 1px solid rgba(99, 102, 241, 0.2);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(99, 102, 241, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-header h2 {
            font-size: 1rem;
            font-weight: 600;
            color: #c4b5fd;
        }

        .panel-header .icon {
            font-size: 1.2rem;
        }

        .panel-content {
            padding: 20px;
        }

        /* Maze Canvas */
        .maze-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        #mazeCanvas {
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(99, 102, 241, 0.3);
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(99, 102, 241, 0.1);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #818cf8;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }

        /* Performance Chart */
        .chart-container {
            height: 120px;
            position: relative;
            margin-top: 16px;
        }

        #performanceChart {
            width: 100%;
            height: 100%;
        }

        /* Glass Box - Reasoning Panel */
        .reasoning-log {
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
        }

        .reasoning-log::-webkit-scrollbar {
            width: 6px;
        }

        .reasoning-log::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .reasoning-log::-webkit-scrollbar-thumb {
            background: rgba(99, 102, 241, 0.5);
            border-radius: 3px;
        }

        .log-entry {
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .log-observe {
            background: rgba(59, 130, 246, 0.15);
            border-left: 3px solid #3b82f6;
        }

        .log-reason {
            background: rgba(168, 85, 247, 0.15);
            border-left: 3px solid #a855f7;
        }

        .log-act {
            background: rgba(34, 197, 94, 0.15);
            border-left: 3px solid #22c55e;
        }

        .log-reflect {
            background: rgba(249, 115, 22, 0.15);
            border-left: 3px solid #f97316;
        }

        .log-adapt {
            background: rgba(236, 72, 153, 0.15);
            border-left: 3px solid #ec4899;
        }

        .log-entry .label {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.65rem;
            letter-spacing: 1px;
            margin-bottom: 4px;
            opacity: 0.8;
        }

        /* Memory Panel */
        .memory-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .memory-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .memory-item .badge {
            background: rgba(99, 102, 241, 0.3);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
        }

        .btn-secondary {
            background: rgba(99, 102, 241, 0.2);
            color: #c4b5fd;
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(99, 102, 241, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Speed Control */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 16px;
            justify-content: center;
        }

        .speed-control label {
            font-size: 0.85rem;
            color: #9ca3af;
        }

        .speed-slider {
            width: 120px;
            accent-color: #6366f1;
        }

        /* Generation Badge */
        .generation-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(139, 92, 246, 0.3));
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
            font-size: 0.85rem;
        }

        .footer a {
            color: #818cf8;
            text-decoration: none;
        }

        /* Comparison View */
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .comparison-item {
            text-align: center;
        }

        .comparison-item h3 {
            font-size: 0.9rem;
            color: #9ca3af;
            margin-bottom: 10px;
        }

        .comparison-canvas {
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Pulse animation for active elements */
        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Progress bar */
        .progress-bar {
            height: 6px;
            background: rgba(99, 102, 241, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #6366f1, #a855f7);
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        /* Strategy effectiveness */
        .strategy-list {
            margin-top: 16px;
        }

        .strategy-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .strategy-name {
            font-size: 0.8rem;
            width: 80px;
            color: #9ca3af;
        }

        .strategy-bar {
            flex: 1;
            height: 8px;
            background: rgba(99, 102, 241, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .strategy-fill {
            height: 100%;
            background: #6366f1;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .strategy-value {
            font-size: 0.8rem;
            width: 40px;
            text-align: right;
            color: #c4b5fd;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Compounding Intelligence</h1>
        <p>Watch AI learn, adapt, and prove its improvement ‚Äî transparently</p>
    </div>

    <div class="container">
        <div class="main-grid">
            <!-- Left Column: Maze + Stats -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <span class="icon">üß©</span>
                        <h2>Learning Task: Maze Navigation</h2>
                        <span class="generation-badge" id="generationBadge">Gen 1</span>
                    </div>
                    <div class="panel-content">
                        <div class="maze-container">
                            <canvas id="mazeCanvas" width="360" height="360"></canvas>
                        </div>
                        <div class="controls">
                            <button class="btn btn-primary" id="startBtn">‚ñ∂ Start Learning</button>
                            <button class="btn btn-secondary" id="resetBtn">‚Üª Reset</button>
                        </div>
                        <div class="speed-control">
                            <label>Speed:</label>
                            <input type="range" class="speed-slider" id="speedSlider" min="1" max="10" value="5">
                            <span id="speedValue">5x</span>
                        </div>
                    </div>
                </div>

                <div class="panel" style="margin-top: 20px;">
                    <div class="panel-header">
                        <span class="icon">üìä</span>
                        <h2>Performance Metrics</h2>
                    </div>
                    <div class="panel-content">
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-value" id="successRate">0%</div>
                                <div class="stat-label">Success Rate</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="avgSteps">‚Äî</div>
                                <div class="stat-label">Avg Steps</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="totalRuns">0</div>
                                <div class="stat-label">Total Runs</div>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="performanceChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Glass Box -->
            <div>
                <div class="panel">
                    <div class="panel-header">
                        <span class="icon">üîç</span>
                        <h2>Glass Box: Agent Reasoning</h2>
                    </div>
                    <div class="panel-content">
                        <div class="reasoning-log" id="reasoningLog">
                            <div class="log-entry log-observe">
                                <div class="label">Ready</div>
                                Click "Start Learning" to begin the demonstration
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel" style="margin-top: 20px;">
                    <div class="panel-header">
                        <span class="icon">üß†</span>
                        <h2>Accumulated Memory</h2>
                    </div>
                    <div class="panel-content">
                        <div class="memory-list" id="memoryList">
                            <div class="memory-item">
                                <span class="badge">Empty</span>
                                <span>No memories yet ‚Äî learning will begin soon</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel" style="margin-top: 20px;">
                    <div class="panel-header">
                        <span class="icon">‚ö°</span>
                        <h2>Strategy Effectiveness</h2>
                    </div>
                    <div class="panel-content">
                        <div class="strategy-list" id="strategyList">
                            <div class="strategy-item">
                                <span class="strategy-name">Random</span>
                                <div class="strategy-bar">
                                    <div class="strategy-fill" style="width: 100%"></div>
                                </div>
                                <span class="strategy-value">100%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Recursive Intelligence Algorithm ‚Äî <a href="https://github.com/ErikG1776/recursive-intelligence-kernel">GitHub</a></p>
        <p style="margin-top: 8px;">AI that gets smarter the more you use it</p>
    </div>

    <script>
        // ============================================
        // Recursive Intelligence - Compounding Demo
        // ============================================

        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const reasoningLog = document.getElementById('reasoningLog');
        const memoryList = document.getElementById('memoryList');
        const strategyList = document.getElementById('strategyList');

        // State
        let isRunning = false;
        let generation = 1;
        let totalRuns = 0;
        let successes = 0;
        let performanceHistory = [];
        let memories = [];
        let strategies = {
            'Random': { uses: 0, successes: 0, weight: 1.0 },
            'Wall-follow': { uses: 0, successes: 0, weight: 0.5 },
            'Greedy': { uses: 0, successes: 0, weight: 0.5 },
            'A* Search': { uses: 0, successes: 0, weight: 0.5 }
        };
        let currentStrategy = 'Random';
        let speed = 5;

        // Maze configuration
        const CELL_SIZE = 24;
        const MAZE_SIZE = 15;
        let maze = [];
        let agent = { x: 1, y: 1 };
        let goal = { x: 13, y: 13 };
        let path = [];
        let steps = 0;
        let allSteps = [];

        // Colors
        const COLORS = {
            wall: '#1e1e2e',
            floor: '#2a2a3e',
            agent: '#6366f1',
            goal: '#22c55e',
            path: 'rgba(99, 102, 241, 0.3)',
            visited: 'rgba(168, 85, 247, 0.2)'
        };

        // Initialize
        function init() {
            generateMaze();
            drawMaze();
            updateStats();
            updateStrategyDisplay();

            document.getElementById('startBtn').addEventListener('click', toggleRunning);
            document.getElementById('resetBtn').addEventListener('click', reset);
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                speed = parseInt(e.target.value);
                document.getElementById('speedValue').textContent = speed + 'x';
            });
        }

        // Generate maze using recursive backtracking
        function generateMaze() {
            // Initialize with walls
            maze = Array(MAZE_SIZE).fill(null).map(() => Array(MAZE_SIZE).fill(1));

            // Carve paths
            function carve(x, y) {
                maze[y][x] = 0;
                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                shuffleArray(directions);

                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx > 0 && nx < MAZE_SIZE - 1 && ny > 0 && ny < MAZE_SIZE - 1 && maze[ny][nx] === 1) {
                        maze[y + dy/2][x + dx/2] = 0;
                        carve(nx, ny);
                    }
                }
            }

            carve(1, 1);
            maze[goal.y][goal.x] = 0;
            maze[1][1] = 0;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Draw maze
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw cells
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    ctx.fillStyle = maze[y][x] === 1 ? COLORS.wall : COLORS.floor;
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }

            // Draw path
            ctx.fillStyle = COLORS.path;
            for (const p of path) {
                ctx.fillRect(p.x * CELL_SIZE + 2, p.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            }

            // Draw goal
            ctx.fillStyle = COLORS.goal;
            ctx.beginPath();
            ctx.arc(goal.x * CELL_SIZE + CELL_SIZE/2, goal.y * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/3, 0, Math.PI * 2);
            ctx.fill();

            // Draw agent
            ctx.fillStyle = COLORS.agent;
            ctx.beginPath();
            ctx.arc(agent.x * CELL_SIZE + CELL_SIZE/2, agent.y * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/3, 0, Math.PI * 2);
            ctx.fill();

            // Agent glow
            ctx.shadowColor = COLORS.agent;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(agent.x * CELL_SIZE + CELL_SIZE/2, agent.y * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // Logging
        function log(type, message) {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `<div class="label">${type}</div>${message}`;
            reasoningLog.insertBefore(entry, reasoningLog.firstChild);

            // Keep only last 50 entries
            while (reasoningLog.children.length > 50) {
                reasoningLog.removeChild(reasoningLog.lastChild);
            }
        }

        // Strategy selection based on learned weights
        function selectStrategy() {
            const totalWeight = Object.values(strategies).reduce((sum, s) => sum + s.weight, 0);
            let random = Math.random() * totalWeight;

            for (const [name, data] of Object.entries(strategies)) {
                random -= data.weight;
                if (random <= 0) {
                    return name;
                }
            }
            return 'Random';
        }

        // Get next move based on strategy
        function getNextMove() {
            const moves = [
                { dx: 0, dy: -1 }, // up
                { dx: 1, dy: 0 },  // right
                { dx: 0, dy: 1 },  // down
                { dx: -1, dy: 0 }  // left
            ];

            const validMoves = moves.filter(m => {
                const nx = agent.x + m.dx;
                const ny = agent.y + m.dy;
                return nx >= 0 && nx < MAZE_SIZE && ny >= 0 && ny < MAZE_SIZE && maze[ny][nx] === 0;
            });

            if (validMoves.length === 0) return null;

            switch (currentStrategy) {
                case 'Random':
                    return validMoves[Math.floor(Math.random() * validMoves.length)];

                case 'Wall-follow':
                    // Prefer moves that keep wall on right
                    return validMoves[0];

                case 'Greedy':
                    // Move towards goal
                    validMoves.sort((a, b) => {
                        const distA = Math.abs(agent.x + a.dx - goal.x) + Math.abs(agent.y + a.dy - goal.y);
                        const distB = Math.abs(agent.x + b.dx - goal.x) + Math.abs(agent.y + b.dy - goal.y);
                        return distA - distB;
                    });
                    return validMoves[0];

                case 'A* Search':
                    // Use A* pathfinding
                    const astarPath = findPath(agent, goal);
                    if (astarPath && astarPath.length > 1) {
                        return { dx: astarPath[1].x - agent.x, dy: astarPath[1].y - agent.y };
                    }
                    return validMoves[0];

                default:
                    return validMoves[0];
            }
        }

        // A* pathfinding
        function findPath(start, end) {
            const openSet = [{ ...start, g: 0, f: 0, parent: null }];
            const closedSet = new Set();

            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();

                if (current.x === end.x && current.y === end.y) {
                    const path = [];
                    let node = current;
                    while (node) {
                        path.unshift({ x: node.x, y: node.y });
                        node = node.parent;
                    }
                    return path;
                }

                closedSet.add(`${current.x},${current.y}`);

                const neighbors = [
                    { x: current.x, y: current.y - 1 },
                    { x: current.x + 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x - 1, y: current.y }
                ];

                for (const n of neighbors) {
                    if (n.x < 0 || n.x >= MAZE_SIZE || n.y < 0 || n.y >= MAZE_SIZE) continue;
                    if (maze[n.y][n.x] === 1) continue;
                    if (closedSet.has(`${n.x},${n.y}`)) continue;

                    const g = current.g + 1;
                    const h = Math.abs(n.x - end.x) + Math.abs(n.y - end.y);
                    const f = g + h;

                    const existing = openSet.find(o => o.x === n.x && o.y === n.y);
                    if (!existing || g < existing.g) {
                        if (existing) {
                            existing.g = g;
                            existing.f = f;
                            existing.parent = current;
                        } else {
                            openSet.push({ x: n.x, y: n.y, g, f, parent: current });
                        }
                    }
                }
            }

            return null;
        }

        // Run one step
        async function runStep() {
            const move = getNextMove();

            if (!move) {
                // Dead end - failed
                await endRun(false);
                return;
            }

            agent.x += move.dx;
            agent.y += move.dy;
            path.push({ x: agent.x, y: agent.y });
            steps++;

            drawMaze();

            // Check if reached goal
            if (agent.x === goal.x && agent.y === goal.y) {
                await endRun(true);
                return;
            }

            // Check step limit - fail fast to learn faster
            if (steps > 200) {
                await endRun(false);
                return;
            }

            // Continue
            if (isRunning) {
                setTimeout(runStep, Math.max(10, 200 - speed * 20));
            }
        }

        // End of run
        async function endRun(success) {
            totalRuns++;
            allSteps.push(steps);

            strategies[currentStrategy].uses++;

            if (success) {
                successes++;
                strategies[currentStrategy].successes++;
                log('act', `‚úì Reached goal in ${steps} steps using ${currentStrategy}`);

                // Add memory
                addMemory(`${currentStrategy} solved maze in ${steps} steps`, 'success');
            } else {
                log('act', `‚úó Failed after ${steps} steps using ${currentStrategy}`);
                addMemory(`${currentStrategy} failed after ${steps} steps`, 'failure');
            }

            // Reflect
            await reflect(success);

            // Update stats
            updateStats();
            updateStrategyDisplay();

            // Check for generation advancement
            if (totalRuns % 5 === 0) {
                generation++;
                document.getElementById('generationBadge').textContent = `Gen ${generation}`;
                log('adapt', `Advanced to Generation ${generation}`);
                generateMaze(); // New maze for new generation
            }

            // Start next run
            if (isRunning) {
                setTimeout(startRun, 500);
            }
        }

        // Reflect and adapt
        async function reflect(success) {
            const successRate = (successes / totalRuns * 100).toFixed(0);

            // Log observation
            log('observe', `Run ${totalRuns}: ${success ? 'Success' : 'Failure'} | Overall: ${successRate}%`);

            // Reason about performance
            const strategyRate = strategies[currentStrategy].uses > 0
                ? (strategies[currentStrategy].successes / strategies[currentStrategy].uses * 100).toFixed(0)
                : 0;

            log('reason', `${currentStrategy} effectiveness: ${strategyRate}% (${strategies[currentStrategy].successes}/${strategies[currentStrategy].uses})`);

            // Adapt strategy weights - AGGRESSIVE learning
            if (success) {
                // Big boost for success
                strategies[currentStrategy].weight = Math.min(10, strategies[currentStrategy].weight * 2.0);
                log('reflect', `Boosting ${currentStrategy} weight to ${strategies[currentStrategy].weight.toFixed(2)}`);

                // If this strategy is proven (3+ successes), make it dominant
                if (strategies[currentStrategy].successes >= 3) {
                    log('adapt', `${currentStrategy} is proven effective - prioritizing it`);
                    strategies[currentStrategy].weight = 10;
                }
            } else {
                // Harsh penalty for failure
                strategies[currentStrategy].weight = Math.max(0.05, strategies[currentStrategy].weight * 0.3);
                log('reflect', `Reducing ${currentStrategy} weight to ${strategies[currentStrategy].weight.toFixed(2)}`);

                // Find best performing strategy
                let bestStrategy = currentStrategy;
                let bestRate = 0;
                for (const [name, data] of Object.entries(strategies)) {
                    if (data.uses > 0) {
                        const rate = data.successes / data.uses;
                        if (rate > bestRate) {
                            bestRate = rate;
                            bestStrategy = name;
                        }
                    }
                }

                if (bestStrategy !== currentStrategy && bestRate > 0) {
                    log('adapt', `Learning: ${bestStrategy} works better (${(bestRate * 100).toFixed(0)}% vs ${strategyRate}%)`);
                }
            }

            // Record performance
            performanceHistory.push(successes / totalRuns * 100);
            drawChart();
        }

        // Add memory
        function addMemory(text, type) {
            memories.unshift({ text, type, generation });

            // Update display
            memoryList.innerHTML = memories.slice(0, 10).map(m => `
                <div class="memory-item">
                    <span class="badge">Gen ${m.generation}</span>
                    <span>${m.text}</span>
                </div>
            `).join('');
        }

        // Start a new run
        function startRun() {
            agent = { x: 1, y: 1 };
            path = [{ x: 1, y: 1 }];
            steps = 0;

            // Select strategy based on learned weights
            currentStrategy = selectStrategy();
            log('observe', `Starting run ${totalRuns + 1} with ${currentStrategy} strategy`);

            drawMaze();
            runStep();
        }

        // Toggle running
        function toggleRunning() {
            isRunning = !isRunning;
            const btn = document.getElementById('startBtn');

            if (isRunning) {
                btn.textContent = '‚è∏ Pause';
                startRun();
            } else {
                btn.textContent = '‚ñ∂ Resume';
            }
        }

        // Reset
        function reset() {
            isRunning = false;
            generation = 1;
            totalRuns = 0;
            successes = 0;
            performanceHistory = [];
            memories = [];
            allSteps = [];
            strategies = {
                'Random': { uses: 0, successes: 0, weight: 1.0 },
                'Wall-follow': { uses: 0, successes: 0, weight: 0.5 },
                'Greedy': { uses: 0, successes: 0, weight: 0.5 },
                'A* Search': { uses: 0, successes: 0, weight: 0.5 }
            };

            document.getElementById('startBtn').textContent = '‚ñ∂ Start Learning';
            document.getElementById('generationBadge').textContent = 'Gen 1';

            generateMaze();
            agent = { x: 1, y: 1 };
            path = [];
            drawMaze();
            updateStats();
            updateStrategyDisplay();

            reasoningLog.innerHTML = `
                <div class="log-entry log-observe">
                    <div class="label">Ready</div>
                    Click "Start Learning" to begin the demonstration
                </div>
            `;

            memoryList.innerHTML = `
                <div class="memory-item">
                    <span class="badge">Empty</span>
                    <span>No memories yet ‚Äî learning will begin soon</span>
                </div>
            `;

            // Clear chart
            const chartCanvas = document.getElementById('performanceChart');
            const chartCtx = chartCanvas.getContext('2d');
            chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
        }

        // Update stats display
        function updateStats() {
            const rate = totalRuns > 0 ? (successes / totalRuns * 100).toFixed(0) : 0;
            document.getElementById('successRate').textContent = rate + '%';
            document.getElementById('totalRuns').textContent = totalRuns;

            if (allSteps.length > 0) {
                const avg = Math.round(allSteps.reduce((a, b) => a + b, 0) / allSteps.length);
                document.getElementById('avgSteps').textContent = avg;
            }
        }

        // Update strategy display
        function updateStrategyDisplay() {
            let html = '';
            for (const [name, data] of Object.entries(strategies)) {
                const rate = data.uses > 0 ? (data.successes / data.uses * 100) : 0;
                html += `
                    <div class="strategy-item">
                        <span class="strategy-name">${name}</span>
                        <div class="strategy-bar">
                            <div class="strategy-fill" style="width: ${rate}%"></div>
                        </div>
                        <span class="strategy-value">${rate.toFixed(0)}%</span>
                    </div>
                `;
            }
            strategyList.innerHTML = html;
        }

        // Draw performance chart
        function drawChart() {
            const chartCanvas = document.getElementById('performanceChart');
            const chartCtx = chartCanvas.getContext('2d');
            const width = chartCanvas.width = chartCanvas.offsetWidth;
            const height = chartCanvas.height = chartCanvas.offsetHeight;

            chartCtx.clearRect(0, 0, width, height);

            if (performanceHistory.length < 2) return;

            // Draw line
            chartCtx.beginPath();
            chartCtx.strokeStyle = '#6366f1';
            chartCtx.lineWidth = 2;

            const stepX = width / (performanceHistory.length - 1);

            for (let i = 0; i < performanceHistory.length; i++) {
                const x = i * stepX;
                const y = height - (performanceHistory[i] / 100 * height);

                if (i === 0) {
                    chartCtx.moveTo(x, y);
                } else {
                    chartCtx.lineTo(x, y);
                }
            }

            chartCtx.stroke();

            // Draw gradient fill
            const gradient = chartCtx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(99, 102, 241, 0.3)');
            gradient.addColorStop(1, 'rgba(99, 102, 241, 0)');

            chartCtx.lineTo(width, height);
            chartCtx.lineTo(0, height);
            chartCtx.fillStyle = gradient;
            chartCtx.fill();
        }

        // Initialize on load
        window.addEventListener('load', init);
        window.addEventListener('resize', () => {
            if (performanceHistory.length > 0) {
                drawChart();
            }
        });
    </script>
</body>
</html>
